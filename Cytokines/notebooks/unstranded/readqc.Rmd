---
title: "ReadQC summary report"
header-includes: #allows you to add in your own Latex packages
- \usepackage{float} #use the 'float' package
- \floatplacement{figure}{H} #make every figure with caption = h
output:
  pdf_document:
    fig_caption: true
    keep_tex: true
    latex_engine: xelatex
  html_document:
    df_print: paged
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(out.extra = '')
#knitr::opts_chunk$set(fig.pos = 'H')
```

# Readqc Summary report {#readqc}

This report contains an aggregated overview of the QC metrics generated by the [FastQC](http://www.bioinformatics.babraham.ac.uk/projects/fastqc/) package for each fastq file.

```{r include=FALSE, echo=FALSE}
library(ggplot2)
library(gridExtra)
library(dplyr)
library(ngsfoo)
source("readqc.config.R")
```

## Sequence quality histograms

A [Phred](https://en.wikipedia.org/wiki/Phred_quality_score) score of ~40 is expected for good quality bases. Base qualities may tail off toward the end of the read and be worse for the second read.

```{r seq-quality, fig.cap='sequence quality histograms', fig.height=5, fig.width=8,  echo=FALSE, message=FALSE}
pbrq <- fetchReadqc(qc_metric="Per_base_sequence_quality")

gp <- ggplot(pbrq, aes_string("Base", "Mean", group="sample", color=plot_color,
                              shape=plot_shape))
gp <- gp + geom_line(alpha=0.75) + geom_point(size=2, alpha=0.75)
gp <- gp + facet_wrap(~end)
gp <- gp + xlab("Position in read") + ylab("Mean quality score")
print(gp)
```

\newpage

## Per tile sequence qualities

The plot shows sequence quality by position in the sequence lane. The color indicates the deviation from the average quality (red=bad, blue=good).

```{r tile-quality, fig.cap='per tile sequence qualities', fig.height=4, fig.width=6,  echo=FALSE, message=FALSE, eval=FALSE}
ptsq <- fetchReadqc(qc_metric="Per_tile_sequence_quality")

tmp <- ptsq %>% group_by(Base, Tile, end) %>% summarise(quality = mean(Mean))
tmp$Tile <- as.factor(tmp$Tile)
lvls <- levels(tmp$Tile)

gp <- ggplot(tmp, aes(Tile,Base)) + geom_raster(aes(fill=quality)) + facet_wrap(~end, scales="free_y")
gp <- gp + scale_fill_gradient2(low="darkred", mid="white", high="darkblue", midpoint=0)
gp <- gp + scale_x_discrete(breaks=lvls[seq(1,length(lvls),by=10)])
print(gp)
```


## Per-sequence Quality Scores

Ideally a peak around a [Phred](https://en.wikipedia.org/wiki/Phred_quality_score) score of 40 is expected.

```{r seq-scores, fig.cap='per sequence quality scores', fig.height=5, fig.width=8,  echo=FALSE, message=FALSE}
pbsq <- fetchReadqc(qc_metric="Per_sequence_quality_scores")

gp <- ggplot(pbsq, aes_string("Quality", "Count", group="sample", color=plot_color, shape=plot_shape))
gp <- gp + geom_line(alpha=0.75) + geom_point(size=2, alpha=0.75)
gp <- gp + facet_wrap(~end, scales="free_y")
gp <- gp + xlab("phred score") + ylab("count")
print(gp)
```

\newpage

## Per-base sequence content

Nucleotide frequency should be largely uniform across the reads.

```{r per-base, fig.cap='per base sequence content', fig.height=8, fig.width=8,  echo=FALSE, message=FALSE}
pbsc <- fetchReadqc(qc_metric="Per_base_sequence_content")

plot_pbsc <- function(pbsc, nucleotide="A")
    {
gp <- ggplot(pbsc, aes_string("Base", nucleotide, group="sample", color=plot_color, shape=plot_shape))
gp <- gp + geom_line(alpha=0.75) + geom_point(size=2, alpha=0.75)
gp <- gp + facet_wrap(~end,scales="free")
gp <- gp + xlab("base position") + ylab(paste0("% ",nucleotide))
gp <- gp + ggtitle(nucleotide)
return(gp)}

gps <- list()
for(base in c("A","T","C","G")) { gps[[base]] <- plot_pbsc(pbsc,base) }

grid.arrange(grobs=gps,ncol=1)
```

\newpage

## Per-sequence GC content

An approximately normal distribution is expected.

```{r gc-content, fig.cap='per sequence GC content', fig.height=5, fig.width=8,  echo=FALSE, message=FALSE}
psgc <- fetchReadqc(qc_metric="Per_sequence_GC_content")

gp <- ggplot(psgc, aes_string("GC_Content", "Count", group="sample", color=plot_color, shape=plot_shape))
gp <- gp + geom_line(alpha=0.75) + geom_point(size=2, alpha=0.75)
gp <- gp + facet_wrap(~end, scales="free_y")
gp <- gp + xlab("mean GC content (%)") + ylab("count")

print(gp)
```


## Per-base N content

N's are assigned when a base's identity cannot be determined. Peaks may be seen at the beginning and end of reads.

```{r n-content, fig.cap='per base n content', fig.height=5, fig.width=8,  echo=FALSE, message=FALSE}
pbnc <- fetchReadqc(qc_metric="Per_base_N_content")

gp <- ggplot(pbnc, aes_string("Base", "N_Count", group="sample", color=plot_color, shape=plot_shape))
gp <- gp + geom_line(alpha=0.75) + geom_point(size=2, alpha=0.75)
gp <- gp + facet_wrap(~end, scales="free_y")
gp <- gp + xlab("Position in read (bp)") + ylab("count")

print(gp)
```

\newpage

## Sequence Length Distribution

If the reads have not been pre-processed (i.e. trimmed) a single peak representing the read-length is expected.

```{r seq-length, fig.cap='sequence length distribution', fig.height=4, fig.width=8,  echo=FALSE, message=FALSE}
sld <- fetchReadqc(qc_metric="Sequence_Length_Distribution")

gp <- ggplot(sld, aes_string("Length", "Count", group="sample", color=plot_color, shape=plot_shape))
gp <- gp + geom_line(alpha=0.75) + geom_point(size=2, alpha=0.75)
gp <- gp + facet_wrap(~end, scales="free_y")
gp <- gp + xlab("Sequence Length (bp)") + ylab("number of sequences")

print(gp)
```

\newpage

## Sequence Duplication Levels

Ideally most of the sequences should be unique (i.e. having a duplication level of 1) - Figure ~\ref{fig:rad} shows the expected fraction of sequences remaining after deduplication.

Failure of the duplication level distribution to flatten when plotted as "percentage of deduplicated" indicates the present of many highly duplicated sequences.

```{r seq-duplication, fig.cap='sequence duplication levels', fig.height=6, fig.width=8,  echo=FALSE, message=FALSE}

sdl = fetchReadqc(qc_metric="Sequence_Duplication_Levels")

sdl$Duplication_Level <- factor(as.character(sdl$Duplication_Level),
                                levels=c("0","1","2","3","4","5","6","7","8","9",
                                         ">10",">50",">100",">500",
                                         ">1k",">2k",">5k",">10k"))

plot_sdl <- function(sdl, sequences)
    {
gp <- ggplot(sdl, aes_string("Duplication_Level", sequences,
                             group="sample", color=plot_color, shape=plot_shape))
gp <- gp + geom_line(alpha=0.75) + geom_point(size=2, alpha=0.75)
gp <- gp + facet_wrap(~end,scales="free_y")
gp <- gp + xlab("Sequence Duplication Level") + ylab("%")
gp <- gp + ggtitle(sequences)
    return(gp)
    }

gps <- list()
gps$pt <- plot_sdl(sdl, "Percentage_of_total")
gps$pd <- plot_sdl(sdl, "Percentage_of_deduplicated")

grid.arrange(grobs=gps,ncol=1)
```


## Percentage of reads remaining after de-duplication

```{r pct-nondup, fig.cap='percentage reads after de-duplication', fig.height=7, fig.width=8,  echo=FALSE, message=FALSE}
sdl2 <- sdl[sdl$Duplication_Level %in% c("1"),]

sdl2$Percent_after_deduplication <- sdl2$Percentage_of_total / sdl2$Percentage_of_deduplicated * 100
sdl2$sample <- factor(sdl2$sample, levels=sdl2$sample[rev(order(sdl2$Percent_after_deduplication))])

gp <- ggplot(sdl2, aes_string("sample", "Percent_after_deduplication",
                              group="sample", color=plot_color, shape=plot_shape))
gp <- gp + geom_point(size=4, alpha=0.75)
gp <- gp + facet_wrap(~end, scales="free_x")
gp <- gp + theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(gp)
```

\newpage

## Over represented sequences

Ideally there should be no or few over-represented sequences and these should represent only a small percentage of the reads. The sequence of over-represented reads is avaliable in the individual FastQC reports.

```{r ors-seq, fig.cap='over-represented sequences', fig.height=4, fig.width=8,  echo=FALSE, message=FALSE, eval=FALSE}
ors <- fetchReadqc(qc_metric="Overrepresented_sequences")

lu <- unique(ors[,c("sample", qc_name_field_titles, "plot_group","end")])
rownames(lu) <- lu$sample

ors$sample <- as.vector(ors$sample)
ors2 <- ors[,c("Count", "Percentage")]
ors2$n_sequences <- 1

orsa <- aggregate(ors2, by=list(ors$sample), FUN=sum)
rownames(orsa) <- orsa$Group.1

ors_data <- merge(lu,orsa,by=0)

gp <- ggplot(ors_data, aes_string("n_sequences", "Percentage",
                                  group="sample", color=plot_color, shape=plot_shape))
gp <- gp + geom_point(size=4, alpha=0.75)
gp <- gp + facet_wrap(~end, scales="free_x")
gp <- gp + theme(axis.text.x = element_text(angle = 90, hjust = 1))
gp <- gp + ylab("% over-represented\nsequences") + xlab("no. over-represented sequences")
print(gp)
```

\newpage

## Adapter content

Reads are examined for the presence of given adapter sequences.

```{r adapter-content, fig.cap='Adapter content', fig.height=9, fig.width=8,  echo=FALSE, message=FALSE}
ac = fetchReadqc(qc_metric="Adapter_Content")
colnames(ac) <- gsub("'", "", colnames(ac))

adapters <- colnames(ac)[!colnames(ac)  %in% c("Position", "sample",
                                               name_field_titles, "read", "plot_group",
                                               "fastq", "fastqc",
                                               "track", "end")]

ac_plot <- function(ac, adapter)
    {
    gp <- ggplot(ac, aes_string("Position", adapter,
                                group="sample", color=plot_color, shape=plot_shape))
    gp <- gp + geom_line(alpha=0.75) + geom_point(size=2, alpha=0.75)
    gp <- gp + facet_wrap(~end, scales="free_x")
    gp <- gp + theme(axis.text.x = element_text(angle = 90, hjust = 1))
    gp <- gp + ylab("% of reads") + xlab("position in read")
    gp <- gp + ggtitle(adapter)
    return(gp)
}

gps = list()
for(adapter in adapters) {gps[[adapter]] <- ac_plot(ac, adapter)}

grid.arrange(grobs=gps, ncol=1)
```


## Kmer content (disabled; no such table)

Presence of highly over-represented kmers may be, for example, caused by over-represented sequences, low-complexity libraries or a problem with the sequencing reaction.

```{r kmer-content, fig.cap='kmer content', fig.height=4, fig.width=8,  echo=FALSE, message=FALSE, eval=FALSE}
kc = fetchReadqc(qc_metric="Kmer_Content")

lu <- unique(kc[,c("sample", unlist(name_field_titles), "plot_group", "end")])
rownames(lu) <- lu$sample

kc$sample <- as.vector(kc$sample)
kc2 <- kc[,c("Count", "Obs_Exp_Max")]
kc2$n_kmers <- 1


kca <- aggregate(kc2, by=list(kc$sample, kc$Max_Obs_Exp_Position), FUN=sum)
kca$position <- kca$Group.2
kca$sample <- kca$Group.1

kc_data <- merge(lu, kca,by.x=0, by.y="sample")


gp <- ggplot(kc_data, aes_string("position", "Count",
                                 group="sample", color=plot_color, shape=plot_shape))
gp <- gp +  geom_point(size=2, alpha=0.75) #geom_line(alpha=0.75) +
gp <- gp + facet_wrap(~end, scales="free_x")
gp <- gp + theme(axis.text.x = element_text(angle = 90, hjust = 1))
gp <- gp + xlab("position in read") + ylab("total kmer count")
print(gp)
```
